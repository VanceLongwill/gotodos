
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vancelongwill/gotodos/handlers/todo.go (74.8%)</option>
				
				<option value="file1">github.com/vancelongwill/gotodos/handlers/user.go (77.8%)</option>
				
				<option value="file2">github.com/vancelongwill/gotodos/middleware/auth.go (88.0%)</option>
				
				<option value="file3">github.com/vancelongwill/gotodos/models/db.go (0.0%)</option>
				
				<option value="file4">github.com/vancelongwill/gotodos/models/todo.go (77.8%)</option>
				
				<option value="file5">github.com/vancelongwill/gotodos/models/user.go (88.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "database/sql"
        "fmt"
        "github.com/gin-gonic/gin"
        "github.com/vancelongwill/gotodos/models"
        "net/http"
        "strconv"
        "time"
)

// Context allows mocking of the gin.Context functions required
type Context interface {
        Get(s string) (string, bool)
        BindJSON(o interface{}) error
        JSON(code int, obj interface{})
        DefaultQuery(key, defaultValue string) string
        Param(s string) string
}

// Todo is a type alias for convenience
type Todo = models.Todo

// TodoStore is the datastore API for todos
type TodoStore interface {
        DBCreateTodo
        DBGetTodo
        DBGetAllTodos
        DBDeleteTodo
        DBMarkTodoAsComplete
        DBUpdateTodo
}

// StringToUint is a util function which converts strings to uints
func StringToUint(n string) (uint, error) <span class="cov8" title="1">{
        u64, err := strconv.ParseUint(n, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return uint(u64), nil</span>
}

func getUserIDFromContext(c *gin.Context) (uint, bool) <span class="cov8" title="1">{
        strUserID, exists := c.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "status":  http.StatusInternalServerError,
                        "message": "Unable to get UserID",
                })
                return 0, false
        }</span>
        <span class="cov8" title="1">return strUserID.(uint), true</span>
}

func getTodoIDFromContext(c *gin.Context) (uint, bool) <span class="cov8" title="1">{
        strTodoID := c.Param("id")
        if len(strTodoID) == 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "status":  http.StatusBadRequest,
                        "message": "Unable to get todo ID",
                })
                return 0, false
        }</span>
        <span class="cov8" title="1">todoID, err := StringToUint(strTodoID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "status":  http.StatusBadRequest,
                        "message": "Can't convert id in url to uint",
                })
                return 0, false
        }</span>

        <span class="cov8" title="1">return todoID, true</span>
}

// DBCreateTodo represents the part of the datalayer responsible for creation
type DBCreateTodo interface {
        CreateTodo(t *Todo) error
}

type CreateRequestBody struct {
        Title string `json:"title"`
        Note  string `json:"note" binding:"required"`
}

// CreateTodo returns a function which handles requests to create todos
func CreateTodo(db DBCreateTodo) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userID, ok := getUserIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">var body CreateRequestBody
                if err := c.BindJSON(&amp;body); err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "status":  http.StatusBadRequest,
                                "message": fmt.Sprintf("Bad request: %s", err.Error()),
                        })
                        return
                }</span>

                <span class="cov8" title="1">todo := Todo{
                        Title:  sql.NullString{body.Title, true},
                        Note:   sql.NullString{body.Note, true},
                        UserID: userID,
                }

                if err := db.CreateTodo(&amp;todo); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "status":     http.StatusInternalServerError,
                                "message":    "Unable to save todo",
                                "resourceId": todo.ID,
                        })
                        return
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                        "status":     http.StatusCreated,
                        "message":    "Todo item created successfully!",
                        "resourceId": todo.ID,
                })</span>
        }
}

// DBGetAllTodos represents the part of the datalayer responsible for getting a list of todos
type DBGetAllTodos interface {
        GetAllTodos(userID, previousID uint) ([]*Todo, error)
}

// GetAllTodos returns a function responsible for handling requests for all the current User's todos
func GetAllTodos(db DBGetAllTodos) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userID, ok := getUserIDFromContext(c)
                if !ok </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">prev := c.DefaultQuery("prev", "0") // use previous id for pagination
                previousID, err := StringToUint(prev)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "status":  http.StatusBadRequest,
                                "message": "Can't convert `prev` query param to uint",
                        })
                }</span>

                <span class="cov8" title="1">todos, err := db.GetAllTodos(userID, previousID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "status":  http.StatusInternalServerError,
                                "message": "Error fetching todos",
                        })
                        return
                }</span>

                <span class="cov8" title="1">if len(todos) &lt;= 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "status":  http.StatusNotFound,
                                "message": "No todo items",
                        })
                        return
                }</span>

                <span class="cov8" title="1">data := make([]map[string]interface{}, len(todos))
                for i, item := range todos </span><span class="cov8" title="1">{
                        data[i] = item.Serialize()
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": http.StatusOK, "data": data})</span>
        }
}

// DBGetTodo represents the part of the datalayer responsible for getting a single todo
type DBGetTodo interface {
        GetTodo(todoID, userID uint) (*Todo, error)
}

// GetTodo returns a function which handles requests to get a single todo
func GetTodo(db DBGetTodo) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userID, ok := getUserIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">todoID, ok := getTodoIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">todo, err := db.GetTodo(todoID, userID)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "status":  http.StatusNotFound,
                                "message": "Unable to find todo",
                        })
                        return
                }</span>

                <span class="cov8" title="1">_todo := todo.Serialize()
                c.JSON(http.StatusOK, gin.H{"status": http.StatusOK, "data": _todo})</span>
        }
}

// DBUpdateTodo represents the part of the datalayer responsible for updating a todo
type DBUpdateTodo interface {
        UpdateTodo(t Todo) (*Todo, error)
}

type UpdateRequestBody struct {
        Title string `json:"title" binding:"required"`
        Note  string `json:"note" binding:"required"`
}

// UpdateTodo returns a function which handles requests to edit an existing Todo
func UpdateTodo(db DBUpdateTodo) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userID, ok := getUserIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">todoID, ok := getTodoIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">var body UpdateRequestBody

                if err := c.BindJSON(&amp;body); err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "status":  http.StatusBadRequest,
                                "message": "Bad request",
                        })
                        return
                }</span>

                <span class="cov8" title="1">if len(body.Title) == 0 &amp;&amp; len(body.Note) == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "status":  http.StatusBadRequest,
                                "message": "Todo title or note must be provided to update",
                        })
                        return
                }</span>

                <span class="cov8" title="1">_todo := Todo{
                        ID:         todoID,
                        UserID:     userID,
                        Title:      sql.NullString{body.Title, true},
                        Note:       sql.NullString{body.Note, true},
                        ModifiedAt: time.Now(),
                }

                todo, err := db.UpdateTodo(_todo)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"status": http.StatusNotFound, "message": "Unable to find todo", "resourceId": todo.ID})
                        return
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": http.StatusOK, "message": "Todo updated successfully!"})</span>
        }
}

// DBDeleteTodo represents the part of the datalayer responsible for deleting a single todo
type DBDeleteTodo interface {
        DeleteTodo(todoID, userID uint) (uint, error)
}

// DeleteTodo returns a function which handles requests to delete a todo
func DeleteTodo(db DBDeleteTodo) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userID, ok := getUserIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">todoID, ok := getTodoIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">deletedTodoID, err := db.DeleteTodo(todoID, userID)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"status": http.StatusNotFound, "message": "Unable to find todo"})
                        return
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": http.StatusOK, "message": "Todo deleted successfully!", "resourceId": deletedTodoID})</span>
        }
}

// DBMarkTodoAsComplete represents the part of the datalayer responsible for updating the completion status of a todo
type DBMarkTodoAsComplete interface {
        MarkTodoAsComplete(todoID, userID uint, currentTime time.Time) error
}

// MarkTodoAsComplete returns a function which handles requests to mark a todo as complete
func MarkTodoAsComplete(db DBMarkTodoAsComplete) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userID, ok := getUserIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">todoID, ok := getTodoIDFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if err := db.MarkTodoAsComplete(todoID, userID, time.Now()); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "status":  http.StatusNotFound,
                                "message": "Unable to find todo",
                        })
                        return
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": http.StatusOK, "message": "Todo marked as complete successfully"})</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "database/sql"
        jwt "github.com/dgrijalva/jwt-go"
        "github.com/gin-gonic/gin"
        "github.com/vancelongwill/gotodos/middleware"
        "github.com/vancelongwill/gotodos/models"
        "golang.org/x/crypto/bcrypt"
        "net/http"
        "time"
)

func createToken(userID uint, expireTime time.Time, secret []byte) (string, error) <span class="cov8" title="1">{
        type Claims = middleware.UserClaims
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, &amp;Claims{
                ID: userID,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expireTime.Unix(),
                },
        })
        return token.SignedString(secret)
}</span>

// User is a type alias for convenience
type User = models.User

// UserStore represents the database layer for Users
type UserStore interface {
        DBGetUser
        DBCreateUser
}

// DBCreateUser represents the part of the datalayer responsible for creation of users
type DBCreateUser interface {
        CreateUser(u *User) (*User, error)
}

type RegisterRequest struct {
        Email     string `json:"email" binding:"required"`
        Password  string `json:"password" binding:"required"`
        FirstName string `json:"firstName" binding:"required"`
        LastName  string `json:"lastName" binding:"required"`
}

// RegisterUser returns a function which handles requests to create a new application user
func RegisterUser(db DBCreateUser, secret []byte) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // RegisterRequest specifies the request body shape for registering a new application user
                var body RegisterRequest
                if err := c.BindJSON(&amp;body); err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "status":  http.StatusBadRequest,
                                "message": "Bad request",
                        })
                        return
                }</span>

                <span class="cov8" title="1">hashBytes, err := bcrypt.GenerateFromPassword([]byte(body.Password), 12)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"status": http.StatusInternalServerError, "message": "Unable to register user"})
                        return
                }</span>

                <span class="cov8" title="1">user := models.User{
                        Email:     body.Email,
                        Password:  string(hashBytes),
                        FirstName: sql.NullString{body.FirstName, true},
                        LastName:  sql.NullString{body.LastName, true},
                }

                newUser, err := db.CreateUser(&amp;user)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"status": http.StatusInternalServerError, "message": "Unable to register user"})
                        return
                }</span>
                <span class="cov8" title="1">expiryInterval := 60 * 60 * 24 * 7
                expiry := time.Now().Add(time.Hour * 24 * 7)

                token, tokenErr := createToken(user.ID, expiry, secret)
                if tokenErr != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"status": http.StatusInternalServerError, "message": "Unable to register user"})
                        return
                }</span>

                <span class="cov8" title="1">c.SetCookie("token", token, expiryInterval, "/", "", false, true)
                c.JSON(http.StatusCreated, gin.H{
                        "status":     http.StatusCreated,
                        "email":      user.Email,
                        "token":      token,
                        "resourceId": newUser.ID,
                        "message":    "User registered successfully!",
                })</span>
        }
}

// DBGetUser represents the part of the datalayer responsible for getting a single user
type DBGetUser interface {
        GetUser(email string) (*User, error)
}

type LoginRequest struct {
        Email    string `json:"email" binding:"required"`
        Password string `json:"password" binding:"required"`
}

// LoginUser returns a function which handles requests to login application users
func LoginUser(db DBGetUser, secret []byte) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // LoginRequest specifies the request body shape for logging in an application user
                var body LoginRequest
                if err := c.BindJSON(&amp;body); err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "status":  http.StatusBadRequest,
                                "message": "Bad request",
                        })
                        return
                }</span>

                <span class="cov8" title="1">user, err := db.GetUser(body.Email)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"status": http.StatusNotFound, "message": "User not found"})
                        return
                }</span>

                <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(body.Password)); err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"status": http.StatusUnauthorized, "message": "Invalid password"})
                        return
                }</span>

                <span class="cov8" title="1">expiry := time.Now().Add(time.Hour * 24 * 7)
                expiryInterval := 60 * 60 * 24 * 7

                token, tokenErr := createToken(user.ID, expiry, secret)
                if tokenErr != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"status": http.StatusInternalServerError, "message": "Unable to login"})
                        return
                }</span>

                <span class="cov8" title="1">c.SetCookie("token", token, expiryInterval, "/", "", false, true)
                c.JSON(http.StatusOK, gin.H{
                        "status":     http.StatusOK,
                        "email":      user.Email,
                        "resourceId": user.ID,
                        "token":      token,
                        "message":    "User logged in successfully!",
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        jwt "github.com/dgrijalva/jwt-go"
        "github.com/gin-gonic/gin"
        "net/http"
        "strings"
)

// UserClaims is used for creating and parsing jwts
type UserClaims struct {
        ID                 uint `json: "id"`
        jwt.StandardClaims      // includes ExpiresAt
}

// Authorize returns a function which blocks unauthorized requests
func Authorize(jwtSecret []byte) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                tokenString, cookieErr := c.Cookie("token")
                if cookieErr != nil </span><span class="cov8" title="1">{ // No token cookie provided
                        authorization := c.Request.Header.Get("Authorization")
                        if len(authorization) == 0 </span><span class="cov8" title="1">{
                                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                        "status":  http.StatusUnauthorized,
                                        "message": "Authorized routes require cookie token or Authorization header",
                                })
                                return
                        }</span>
                        <span class="cov8" title="1">authorizationParts := strings.Split(authorization, " ")
                        if len(authorizationParts) != 2 </span><span class="cov8" title="1">{
                                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
                                        "status":  http.StatusBadRequest,
                                        "message": "Authorization header should be in the format `Bearer $TOKEN`",
                                })
                                return
                        }</span>
                        <span class="cov8" title="1">tokenString = authorizationParts[1]</span>
                }

                <span class="cov8" title="1">var claims UserClaims

                token, tokenErr := jwt.ParseWithClaims(tokenString, &amp;claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        return jwtSecret, nil
                }</span>)

                <span class="cov8" title="1">if tokenErr != nil </span><span class="cov8" title="1">{
                        if tokenErr == jwt.ErrSignatureInvalid </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                        "status":  http.StatusUnauthorized,
                                        "message": "Invalid signature",
                                })
                        }</span> else<span class="cov8" title="1"> {
                                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
                                        "status":  http.StatusBadRequest,
                                        "message": "Invalid token",
                                })
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "status":  http.StatusUnauthorized,
                                "message": "Invalid token",
                        })
                        return
                }</span>

                // JWT is valid, proceed
                <span class="cov8" title="1">c.Set("userID", claims.ID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "database/sql"
        "fmt"
        _ "github.com/lib/pq" // postgres driver
)

// DB is the database
type DB struct {
        *sql.DB
}

// NewDB makes &amp; tests a connection with the DB specified then returns it
func NewDB(host, port, user, password, dbname string) (*DB, error) <span class="cov0" title="0">{
        // open a db connection
        connectstring := fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                host, port, user, password, dbname)
        db, err := sql.Open("postgres", connectstring)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if connecterr := db.Ping(); connecterr != nil </span><span class="cov0" title="0">{
                return nil, connecterr
        }</span>
        <span class="cov0" title="0">return &amp;DB{db}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "database/sql"
        "errors"
        "github.com/lib/pq"
        "time"
)

// Todo defines the shape of a single todo item
type Todo struct {
        ID          uint
        Title       sql.NullString
        Note        sql.NullString
        CreatedAt   time.Time
        ModifiedAt  time.Time
        DueAt       pq.NullTime // Specific to postgres
        UserID      uint
        CompletedAt pq.NullTime // Specific to postgres
        IsDone      bool
}

const (
        resultsPerPage = 10 // the default page size for todos
)

// Errors
var (
        ErrorEmptyTodo      = errors.New("Todo must have non empty title or note")
        ErrorRowsUnaffected = errors.New("Rows were not changed successfully")
)

// Serialize converts the todo struct to a simple string map for conversion to JSON
func (t *Todo) Serialize() map[string]interface{} <span class="cov8" title="1">{
        mappedTodo := map[string]interface{}{
                "id":         t.ID,
                "isDone":     t.IsDone,
                "createdAt":  t.CreatedAt,
                "modifiedAt": t.ModifiedAt,
        }

        if t.Title.Valid </span><span class="cov8" title="1">{
                mappedTodo["title"] = t.Title.String
        }</span>
        <span class="cov8" title="1">if t.Note.Valid </span><span class="cov8" title="1">{
                mappedTodo["note"] = t.Note.String
        }</span>
        <span class="cov8" title="1">if t.DueAt.Valid </span><span class="cov8" title="1">{
                mappedTodo["dueAt"] = t.DueAt.Time
        }</span>
        <span class="cov8" title="1">if t.CompletedAt.Valid </span><span class="cov8" title="1">{
                mappedTodo["completedAt"] = t.CompletedAt.Time
        }</span>

        <span class="cov8" title="1">return mappedTodo</span>
}

// CreateTodo inserts a single todo into an sql database
func (db *DB) CreateTodo(t *Todo) error <span class="cov8" title="1">{
        if len(t.Title.String) == 0 &amp;&amp; len(t.Note.String) == 0 </span><span class="cov8" title="1">{
                return ErrorEmptyTodo
        }</span>
        <span class="cov8" title="1">sqlStatement := `
        INSERT INTO todos (title, note, user_id)
        VALUES ($1, $2, $3);`

        res, err := db.Exec(sqlStatement, t.Title, t.Note, t.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if count != 1 </span><span class="cov0" title="0">{
                return ErrorRowsUnaffected
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetAllTodos finds all the todos for a given user and page in an sql database
func (db *DB) GetAllTodos(userID, previousID uint) ([]*Todo, error) <span class="cov8" title="1">{
        sqlStatement := `
        SELECT * FROM todos WHERE user_id = $1 AND id &gt; $3
        LIMIT $2;`
        rows, err := db.Query(sqlStatement, userID, resultsPerPage, previousID)

        defer rows.Close()

        todos := make([]*Todo, 0)
        for rows.Next() </span><span class="cov8" title="1">{
                t := new(Todo)
                if err := rows.
                        Scan(&amp;t.ID, &amp;t.Title, &amp;t.Note, &amp;t.CreatedAt, &amp;t.ModifiedAt, &amp;t.DueAt, &amp;t.UserID, &amp;t.CompletedAt, &amp;t.IsDone); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">todos = append(todos, t)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if todos == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Empty DB")
        }</span>
        <span class="cov8" title="1">return todos, nil</span>
}

// GetTodo finds a single todo from an sql database
func (db *DB) GetTodo(todoID, userID uint) (*Todo, error) <span class="cov8" title="1">{
        sqlStatement := `
        SELECT * FROM todos WHERE id = $1 AND user_id = $2`
        todo := new(Todo)
        err := db.QueryRow(sqlStatement, todoID, userID).
                Scan(&amp;todo.ID, &amp;todo.Title, &amp;todo.Note, &amp;todo.CreatedAt,
                        &amp;todo.ModifiedAt, &amp;todo.DueAt, &amp;todo.UserID, &amp;todo.CompletedAt, &amp;todo.IsDone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return todo, nil</span>
}

// MarkTodoAsComplete changes the is_done field to true and adds a completed_at timestamp for a given todo in an sql database
func (db *DB) MarkTodoAsComplete(todoID, userID uint, currentTime time.Time) error <span class="cov8" title="1">{
        sqlStatement := `
        UPDATE todos
        SET completed_at = $3, is_done = TRUE 
        WHERE id = $1 AND user_id = $2;`

        res, err := db.Exec(sqlStatement, todoID, userID, currentTime)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if count != 1 </span><span class="cov0" title="0">{
                return ErrorRowsUnaffected
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateTodo changes the title and note of a single todo in an sql database
func (db *DB) UpdateTodo(t Todo) (*Todo, error) <span class="cov8" title="1">{
        sqlStatement := `
        UPDATE todos
        SET title = $3, note = $4, modified_at = $5
        WHERE id = $1 AND user_id = $2;`

        res, err := db.Exec(sqlStatement, t.ID, t.UserID, t.Title, t.Note, t.ModifiedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if count != 1 </span><span class="cov0" title="0">{
                return nil, ErrorRowsUnaffected
        }</span>
        <span class="cov8" title="1">return &amp;t, nil</span>
}

// DeleteTodo removes a single todo from an sql database
func (db *DB) DeleteTodo(todoID, userID uint) (uint, error) <span class="cov8" title="1">{
        sqlStatement := `
        DELETE FROM todos
        WHERE id = $1 AND user_id = $2;`
        res, err := db.Exec(sqlStatement, todoID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if count != 1 </span><span class="cov0" title="0">{
                return 0, ErrorRowsUnaffected
        }</span>
        <span class="cov8" title="1">return todoID, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "database/sql"
)

// User defines the shape of an application user
type User struct {
        ID        uint
        FirstName sql.NullString
        LastName  sql.NullString
        Email     string
        Password  string
}

// Serialize converts the user struct to a simple string map for conversion to JSON
func (u *User) Serialize() map[string]interface{} <span class="cov8" title="1">{
        mappedUser := map[string]interface{}{
                "id":    u.ID,
                "email": u.Email,
        }
        if u.FirstName.Valid </span><span class="cov8" title="1">{
                mappedUser["firstName"] = u.FirstName.String
        }</span>
        <span class="cov8" title="1">if u.LastName.Valid </span><span class="cov8" title="1">{
                mappedUser["lastName"] = u.LastName.String
        }</span>
        <span class="cov8" title="1">return mappedUser</span>
}

// GetUser finds a single user from an sql database
func (db *DB) GetUser(email string) (*User, error) <span class="cov8" title="1">{
        sqlStatement := `SELECT * FROM users WHERE email = $1`
        u := new(User)
        err := db.QueryRow(sqlStatement, email).Scan(&amp;u.ID, &amp;u.FirstName, &amp;u.LastName, &amp;u.Email, &amp;u.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return u, nil</span>
}

// CreateUser inserts a single new user into an sql database
func (db *DB) CreateUser(u *User) (*User, error) <span class="cov8" title="1">{
        sqlStatement := `
        INSERT INTO users (email, first_name, last_name, password_hash)
        VALUES ($1, $2, $3, $4)
        RETURNING id;`

        err := db.QueryRow(sqlStatement, u.Email, u.FirstName, u.LastName, u.Password).Scan(&amp;u.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return u, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
